import re
from itertools import zip_longest
from typing import Union

from sqlalchemy import select
from sqlalchemy.exc import NoResultFound

from detection_service.models import AppBundleOrm
from detection_service.models import CpeOrm

from .commands import setup_database

session = setup_database()

APPLE_OS_LIST = (
    "desktopmac",
    "desktopmac_os",
    "desktopmac_os_x",
    "mac",
    "mac_os",
    "mac_os_x",
    "machine",
    "macintosh",
    "macintosh_corporate",
    "macos",
    "macos:zh",
    "promac_os",
    "promacos",
    "uniform_distributioniphone_os",
    "businessiphone_os",
    "exponential_distributioniphone_os",
    "ipad2",
    "ipados",
    "iphone",
    "iphone_os",
    "iphone_osipad",
)

CPE_2_3 = "cpe:2.3"


def parse_cpe_23(cpe: Union[str, CpeOrm]) -> CpeOrm:
    cpe_uri = ""
    obj = None

    # verify the type we're parsing
    if isinstance(cpe, str):
        cpe_uri = cpe
    elif isinstance(cpe, CpeOrm):
        cpe_uri = cpe.uri

    split_cpe = cpe_uri.split(":")
    cpe_version_prefix = f"{split_cpe[0]}:{split_cpe[1]}"

    # some CPE's don't specify the version
    if cpe_version_prefix == CPE_2_3:
        cpe_elements = [cpe_uri] + [f"{cpe_version_prefix}"] + split_cpe[2:]
    else:
        cpe_elements = [cpe_uri] + [f"{split_cpe[0]}"] + split_cpe[1:]

    # null id is a new obj, existing id means we're updating obj
    cols = CpeOrm.__table__.columns.keys()
    cols.remove("id")

    # not all CPE's have enough values to fill the columns, so we default to empty str
    values = {
        col: cpe_part for col, cpe_part in zip_longest(cols, cpe_elements, fillvalue="")
    }

    # new instance
    if isinstance(cpe, str):
        obj = CpeOrm(**values)
    # update existing instance
    elif isinstance(cpe, CpeOrm):
        [setattr(cpe, attr, values.get(attr)) for attr in cols]
        obj = cpe

    return obj


def _match(app_bundle: AppBundleOrm):
    # every CPE specifies a vendor
    if not app_bundle.vendor and not app_bundle.vendor.name:
        raise Exception(f"No vendor specified for App {app_bundle.id}")

    application_name = app_bundle.application_name.removesuffix(".app").lower()
    vendor_name = app_bundle.vendor.name.lower()

    # 1. exact match on name, vendor, version, and (target_os or *)
    q = select(CpeOrm).where(
        CpeOrm.product == application_name,
        CpeOrm.vendor == vendor_name,
        CpeOrm.version.in_(
            (
                app_bundle.bundle_version.lower(),
                "*",
            )
        ),
        CpeOrm.target_software.in_(APPLE_OS_LIST + ("*",)),
    )
    cpes = session.execute(q).all()

    # 2. exact match could not be found, try fuzzy matching
    if not cpes:
        print(f"Fuzzy matching App {app_bundle.id}")
        # ---
        # overlap_product  - bundle name overlaps cpe product name, filter by "true"
        # overlap_vendor   - vendor name overlaps cpe vendor name, filter by "true"
        # lev_product      - lev. dist., filter by lte product str len
        # lev_vendor       - lev. dist., filter by lte vendor str len
        # version          - includes specific bundle version and '*'
        # target_software  - includes specific bundle target_software/os and '*'
        # ---
        regex = "[^a-zA-Z0-9]"
        product_arr = [x.lower() for x in re.split(regex, application_name) if x]
        vendor_arr = [x.lower() for x in re.split(regex, vendor_name) if x]

        q = f"""
        SELECT *
        FROM (
                 SELECT id,
                        uri,
                        levenshtein(lower('{application_name}'), product) AS lev_product,
                        levenshtein(lower('{vendor_name}'), vendor) AS lev_vendor,
                        ARRAY{product_arr} && regexp_split_to_array(product, '{regex}') AS overlap_product,
                        ARRAY{vendor_arr} && regexp_split_to_array(vendor, '{regex}') AS overlap_vendor,
                        version,
                        target_software
                 FROM cpe
                 WHERE part = 'a'
                   AND cpe_version_prefix = 'cpe:2.3'
                   AND version in {(app_bundle.bundle_version.lower(), "*",)}
                   AND target_software IN {(app_bundle.os.lower(), "*",)}
             ) AS t
        WHERE overlap_product = true
          AND overlap_vendor = true
          AND lev_product <= length('{application_name}')
          AND lev_vendor <= length('{vendor_name}')
        ORDER BY lev_product ASC,
                 lev_vendor ASC,
                 version DESC,
                 target_software DESC;
        """
        results = session.execute(q).all()
        cpes = session.execute(
            select(CpeOrm).where(CpeOrm.id.in_([row[0] for row in results]))
        ).all()

    # attach CPE to app bundle
    if cpes:
        app_bundle_cpes_ids = {row.id for row in app_bundle.cpes}
        cpes_ids = {row[0].id for row in cpes}

        to_remove = app_bundle_cpes_ids.difference(cpes_ids)
        to_add = cpes_ids.difference(app_bundle_cpes_ids)

        for cpe in [row[0] for row in app_bundle.cpes if row.id in to_remove]:
            app_bundle.cpes.remove(cpe)

        for cpe in [row[0] for row in cpes if row[0].id in to_add]:
            app_bundle.cpes.append(cpe)

        app_bundle.verified = False

        session.add(app_bundle)
        session.commit()
    else:
        print(f"No CPE matches found for App {app_bundle.id}")

    return {
        "id": f"{app_bundle.id}",
        "application_name": f"{app_bundle.application_name}",
        "bundle_version": f"{app_bundle.bundle_version}",
        "cpes": [cpe.uri for cpe in app_bundle.cpes],
    }


def match_app_bundle_to_cpe(app_id: int = None):
    # match specific app
    if app_id:
        try:
            q = select(AppBundleOrm).where(AppBundleOrm.id == app_id)
            app_bundle = session.execute(q).one()
            yield _match(app_bundle)
        except NoResultFound:
            print(f"No Apps with ID: {app_id}")

    # iterate through unmatched apps
    else:
        batch_size = 100
        q = (
            select(AppBundleOrm)
            .where(AppBundleOrm.verified == None)  # noqa: E711 "is None" doesn't work
            .execution_options(yield_per=batch_size)
        )

        for partition in session.execute(q).partitions(batch_size):
            for app_bundle in partition:
                yield _match(app_bundle)
