import logging
import os
import time
from datetime import datetime
from datetime import timedelta
from datetime import timezone

import requests
from commands import setup_database
from commands import setup_kandji_tools
from commands import setup_redis
from models import CPECVEMatchOrm
from models import CPEOrm
from models import CVEOrm
from requests.adapters import HTTPAdapter
from requests.adapters import Retry
from sqlalchemy.dialects.postgresql import insert


class CVEHandler:
    def __init__(self):
        self.query_url = "https://services.nvd.nist.gov/rest/json/cves/1.0/"

    def store_results(self, results):
        cves = results["result"]["CVE_Items"]

        if len(cves) > 0:
            logger.info(f"{len(cves)} new CVEs found")
        else:
            return

        values = []
        for item in cves:
            cvss_v3 = item.get("impact", {}).get("baseMetricV3", {}).get("cvssV3", {})

            values.append(
                {
                    "cve_id": item["cve"]["CVE_data_meta"]["ID"],
                    "severity": cvss_v3.get("baseSeverity"),
                    "version": cvss_v3.get("version"),
                    "score": cvss_v3.get("baseScore"),
                }
            )

        insert_stmt = insert(CVEOrm, values)
        session.execute(
            insert_stmt.on_conflict_do_update(
                constraint="cves_pkey",
                set_={
                    "severity": insert_stmt.excluded.severity,
                    "version": insert_stmt.excluded.version,
                    "score": insert_stmt.excluded.score,
                },
            )
        )
        session.commit()

    def should_paginate(self, results):
        results["totalResults"] > results["resultsPerPage"]


class CPEHandler:
    def __init__(self):
        self.query_url = "https://services.nvd.nist.gov/rest/json/cpes/1.0/?addOns=cves"

    # TODO: Remove cve insertion once historical data is filled (https://kandji.atlassian.net/browse/VULN-70)
    #   Once all historical data is loaded we should already be guaranteed to have all cves by this point
    #   This just ensures things aren't breaking locally in the meantime
    def store_results(self, results):
        cpes = results["result"]["cpes"]

        if len(cpes) > 0:
            logger.info(f"{len(cpes)} new CPEs found")
        else:
            return

        cpe_values = []
        cve_values = []
        cpe_cve_match_values = []
        for item in cpes:
            cpe_values.append({"cpe_id": item["cpe23Uri"]})

            vulnerabilities = item["vulnerabilities"]
            if "" in vulnerabilities:
                vulnerabilities.remove("")

            for cve_id in vulnerabilities:
                cve_values.append({"cve_id": cve_id})
                cpe_cve_match_values.append(
                    {"cve_row_id": cve_id, "cpe_row_id": item["cpe23Uri"]}
                )

        insert_cpe_stmt = insert(CPEOrm, cpe_values)
        session.execute(insert_cpe_stmt.on_conflict_do_nothing(constraint="cpes_pkey"))

        if cpe_cve_match_values:
            logger.info(f"{len(cpe_cve_match_values)} new cpe/cve matches found")

            self.delete_cpe_cve_matches(cpe_cve_match_values)

            insert_cve_stmt = insert(CVEOrm, cve_values)
            insert_cpe_cve_match_stmt = insert(CPECVEMatchOrm, cpe_cve_match_values)

            session.execute(
                insert_cve_stmt.on_conflict_do_nothing(constraint="cves_pkey")
            )
            session.execute(insert_cpe_cve_match_stmt)

        session.commit()

    def delete_cpe_cve_matches(self, cpe_cve_match_values):
        cpe_ids = [match["cpe_row_id"] for match in cpe_cve_match_values]
        session.query(CPECVEMatchOrm).filter(
            CPECVEMatchOrm.cpe_row_id.in_(cpe_ids)
        ).delete()

    def should_paginate(self, results):
        results["totalResults"] > results["resultsPerPage"]


class NVD:
    def __init__(self):
        self.page_size = 500
        self.index = 0
        self.datetime_format = "%Y-%m-%dT%H:%M:%S:000 UTC"
        self.start_datetime = self.get_start_datetime()
        self.end_datetime = datetime.now(timezone.utc).strftime(self.datetime_format)

    def get_recent_data(self):
        logger.info("Querying for recently published/modified CVEs...")
        self.get_recent_data_for_type(CVEHandler())

        logger.info("Querying for recently published/modified CPEs...")
        self.get_recent_data_for_type(CPEHandler())

        logger.info("Updating last_nvd_query_datetime")
        redis_conn.set("last_nvd_query_datetime", self.end_datetime)

    def get_recent_data_for_type(self, handler):
        paginate = True

        while paginate:
            results = self.get_data(handler)

            handler.store_results(results)

            if handler.should_paginate(results):
                self.index += self.page_size
                # https://nvd.nist.gov/developers recommends sleeping for 6 seconds
                #   between requests to avoid rate limiting
                time.sleep(6)
            else:
                paginate = False

    def get_data(self, handler):
        return request_session.get(
            handler.query_url,
            params={
                "modStartDate": self.start_datetime,
                "modEndDate": self.end_datetime,
                "resultsPerPage": self.page_size,
                "startIndex": self.index,
                "apikey": os.getenv("NVD_API_KEY"),
            },
            timeout=60,
        ).json()

    def get_start_datetime(self):
        start_datetime = redis_conn.get("last_nvd_query_datetime")

        if not start_datetime:
            start_datetime = (datetime.now(timezone.utc) - timedelta(days=4)).strftime(
                self.datetime_format
            )

        return start_datetime


if __name__ == "__main__":
    setup_kandji_tools()
    session = setup_database()
    logger = logging.getLogger()
    redis_conn = setup_redis()
    request_session = requests.Session()
    retries = Retry(total=3, backoff_factor=1)
    request_session.mount("https://", HTTPAdapter(max_retries=retries))

    NVD().get_recent_data()
