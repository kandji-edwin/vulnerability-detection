import logging
import os
import time
from datetime import datetime
from datetime import timedelta
from datetime import timezone

import Levenshtein as lev
import requests
from commands import setup_database
from commands import setup_kandji_tools
from commands import setup_redis
from models import AppBundleOrm
from models import CPECVEMatchOrm
from models import CPEOrm
from models import CVEOrm
from models import ReferenceDataOrm
from models import ReferenceDataTagOrm
from requests.adapters import HTTPAdapter
from requests.adapters import Retry
from sqlalchemy import delete
from sqlalchemy import func
from sqlalchemy import inspect
from sqlalchemy import select
from sqlalchemy import update
from sqlalchemy.dialects.postgresql import insert


class CVEHandler:
    def __init__(self):
        self.query_url = "https://services.nvd.nist.gov/rest/json/cves/1.0/"

    def store_results(self, results):
        cves = results["result"]["CVE_Items"]

        if len(cves) > 0:
            logger.info(f"{len(cves)} new CVEs found")
        else:
            return

        cve_values = []
        ref_values = []
        ref_tag_dict = {}

        for item in cves:
            cvss_v3 = item.get("impact", {}).get("baseMetricV3", {}).get("cvssV3", {})
            description = [
                desc["value"]
                for desc in item["cve"]["description"]["description_data"]
                if desc["lang"] == "en"
            ][0]

            cve_values.append(
                {
                    CVEOrm.cve_id: item["cve"]["CVE_data_meta"]["ID"],
                    CVEOrm.severity: cvss_v3.get("baseSeverity"),
                    CVEOrm.version: cvss_v3.get("version"),
                    CVEOrm.score: cvss_v3.get("baseScore"),
                    CVEOrm.description: description,
                    CVEOrm.published_date: item["publishedDate"],
                    CVEOrm.last_modified_date: item["lastModifiedDate"],
                }
            )

            ref_tag_dict[item["cve"]["CVE_data_meta"]["ID"]] = {}
            for ref in item["cve"]["references"]["reference_data"]:
                ref_values.append(
                    {
                        ReferenceDataOrm.cve_row_id: item["cve"]["CVE_data_meta"]["ID"],
                        ReferenceDataOrm.url: ref["url"],
                    }
                )

                ref_tag_dict[item["cve"]["CVE_data_meta"]["ID"]][ref["url"]] = ref[
                    "tags"
                ]

        insert_stmt = insert(CVEOrm).values(cve_values)
        pk_constraint_name = inspector.get_pk_constraint(CVEOrm.__tablename__)["name"]
        session.execute(
            insert_stmt.on_conflict_do_update(
                constraint=pk_constraint_name,
                set_={
                    column.key: insert_stmt.excluded[column.key]
                    for column in CVEOrm.__table__.columns
                },
            )
        )
        session.commit()

        self.delete_references(cve_values)
        self.insert_references(ref_values, ref_tag_dict)

    def insert_references(self, ref_values, ref_tag_dict):
        references = []

        insert_ref_stmt = (
            insert(ReferenceDataOrm)
            .values(ref_values)
            .returning(
                ReferenceDataOrm.id, ReferenceDataOrm.cve_row_id, ReferenceDataOrm.url
            )
        )
        references = session.execute(insert_ref_stmt).fetchall()

        tag_values = []
        for ref in references:
            for tag in ref_tag_dict.get(ref.cve_row_id, {}).get(ref.url, []):
                tag_values.append(
                    {
                        ReferenceDataTagOrm.reference_data_id: ref.id,
                        ReferenceDataTagOrm.tag: tag,
                    }
                )

        if tag_values:
            insert_tag_stmt = insert(ReferenceDataTagOrm).values(tag_values)
            session.execute(insert_tag_stmt)

        session.commit()

    def delete_references(self, cve_values):
        cve_ids = [cve[CVEOrm.cve_id] for cve in cve_values]
        delete_stmt = delete(ReferenceDataOrm).where(
            ReferenceDataOrm.cve_row_id.in_(cve_ids)
        )
        session.execute(delete_stmt)

    def should_paginate(self, results):
        return results["totalResults"] > results["resultsPerPage"]


class CPEHandler:
    def __init__(self):
        self.query_url = "https://services.nvd.nist.gov/rest/json/cpes/1.0/?addOns=cves"

    # Assumes that cpe_str matches regex in https://csrc.nist.gov/schema/cpe/2.3/cpe-naming_2.3.xsd
    @staticmethod
    def parse_cpe_23(cpe_str: str):
        split_cpe = cpe_str.split(":")
        cpe_elements = [cpe_str] + [f"{split_cpe[0]}:{split_cpe[1]}"] + split_cpe[2:]

        return {
            column.key: cpe_part
            for column, cpe_part in zip(CPEOrm.__table__.columns, cpe_elements)
        }

    @staticmethod
    def match_cpes_to_app_bundles(cpe_list: list):
        #  Do where query that gets the subset of
        #  possible candidates Try to match CPE product -> Bundle application name, CPE version -> Bundle
        #  bundle_version, CPE vendor -> Bundle bundle_identifier (this is a "reverse dns" which contains company in it)
        for cpe_item in cpe_list:
            candidates_stmt = select(AppBundleOrm).where(
                AppBundleOrm.bundle_version == cpe_item[CPEOrm.version.key],
                func.lower(
                    func.replace(AppBundleOrm.application_name, ".", "")
                ).contains(cpe_item[CPEOrm.product.key].replace("_", "")),
            )
            results = session.execute(candidates_stmt).scalars().all()

            narrowed_list = []
            if len(results) > 1:
                # Further narrow down, find substring matches then find best one
                for result in results:
                    cpe_vendor = cpe_item[CPEOrm.vendor.key]
                    bundle_vendor = result.bundle_identifier.lower()
                    if cpe_vendor in bundle_vendor:
                        narrowed_list.append(
                            (lev.distance(cpe_vendor, bundle_vendor), result)
                        )

                results = (
                    narrowed_list.sort(key=lambda x: x[0])[0][1]
                    if narrowed_list
                    else narrowed_list
                )

            # If candidate is found, set the foreign key of app bundle to point to the cpe
            if len(results) == 1:
                insert_app_stmt = (
                    update(AppBundleOrm)
                    .where(
                        AppBundleOrm.bundle_version == results[0].bundle_version,
                        AppBundleOrm.bundle_identifier == results[0].bundle_identifier,
                    )
                    .values(
                        {
                            AppBundleOrm.cpe_row_id: cpe_item[CPEOrm.cpe_id.key],
                            AppBundleOrm.verified: False,
                        }
                    )
                )
                session.execute(insert_app_stmt)

    def store_results(self, results):
        cpes = results["result"]["cpes"]

        if len(cpes) > 0:
            logger.info(f"{len(cpes)} new CPEs found")
        else:
            return

        cpe_values = []
        cpe_cve_match_values = []

        for item in cpes:
            parsed_cpe_dict = CPEHandler.parse_cpe_23(item["cpe23Uri"])
            cpe_values.append(parsed_cpe_dict)

            vulnerabilities = item["vulnerabilities"]
            if "" in vulnerabilities:
                vulnerabilities.remove("")

            for cve_id in vulnerabilities:
                cpe_cve_match_values.append(
                    {
                        CPECVEMatchOrm.cve_row_id: cve_id,
                        CPECVEMatchOrm.cpe_row_id: item["cpe23Uri"],
                    }
                )

        insert_cpe_stmt = insert(CPEOrm).values(cpe_values)

        pk_constraint_name = inspector.get_pk_constraint(CPEOrm.__tablename__)["name"]
        insert_cpe_stmt = insert_cpe_stmt.on_conflict_do_update(
            constraint=pk_constraint_name,
            set_={
                column.key: insert_cpe_stmt.excluded[column.key]
                for column in CPEOrm.__table__.columns
            },
        ).returning(CPEOrm)

        result = session.execute(insert_cpe_stmt)

        CPEHandler.match_cpes_to_app_bundles(
            [
                dict(zip(pk_tuple.keys(), pk_tuple))
                for pk_tuple in result.all()
                if pk_tuple[CPEOrm.part.key] == "a"
            ]
        )

        if cpe_cve_match_values:
            stored_cve_ids = self.get_stored_cve_ids(cpe_cve_match_values)

            valid_matches = list(
                filter(
                    lambda match: match[CPECVEMatchOrm.cve_row_id] in stored_cve_ids,
                    cpe_cve_match_values,
                )
            )

            logger.info(f"{len(valid_matches)} new cpe/cve matches found")

            self.delete_cpe_cve_matches(valid_matches)

            insert_cpe_cve_match_stmt = insert(CPECVEMatchOrm).values(valid_matches)
            session.execute(insert_cpe_cve_match_stmt)

        session.commit()

    def delete_cpe_cve_matches(self, cpe_cve_match_values):
        cpe_ids = [match[CPECVEMatchOrm.cpe_row_id] for match in cpe_cve_match_values]
        delete_stmt = delete(CPECVEMatchOrm).where(
            CPECVEMatchOrm.cpe_row_id.in_(cpe_ids)
        )
        session.execute(delete_stmt)

    def get_stored_cve_ids(self, collection):
        cve_ids = [item[CPECVEMatchOrm.cve_row_id] for item in collection]
        select_stmt = select(CVEOrm.cve_id).where(CVEOrm.cve_id.in_(cve_ids))
        stored_cves = session.execute(select_stmt)

        return [cve.cve_id for cve in stored_cves]

    def should_paginate(self, results):
        return results["totalResults"] > results["resultsPerPage"]


class NVD:
    def __init__(self):
        self.page_size = 500
        self.index = 0
        self.datetime_format = "%Y-%m-%dT%H:%M:%S:000 UTC"
        self.start_datetime = self.get_start_datetime()
        self.end_datetime = datetime.now(timezone.utc).strftime(self.datetime_format)

    def get_recent_data(self):
        logger.info("Querying for recently published/modified CVEs...")
        self.get_recent_data_for_type(CVEHandler())

        logger.info("Querying for recently published/modified CPEs...")
        self.get_recent_data_for_type(CPEHandler())

        logger.info("Updating last_nvd_query_datetime")
        redis_conn.set("last_nvd_query_datetime", self.end_datetime)

    def get_recent_data_for_type(self, handler):
        paginate = True

        while paginate:
            results = self.get_data(handler)

            handler.store_results(results)

            if handler.should_paginate(results):
                self.index += self.page_size
                # https://nvd.nist.gov/developers recommends sleeping for 6 seconds
                #   between requests to avoid rate limiting
                time.sleep(6)
            else:
                paginate = False

    def get_data(self, handler):
        return request_session.get(
            handler.query_url,
            params={
                "modStartDate": self.start_datetime,
                "modEndDate": self.end_datetime,
                "resultsPerPage": self.page_size,
                "startIndex": self.index,
                "apikey": os.getenv("NVD_API_KEY"),
            },
            timeout=60,
        ).json()

    def get_start_datetime(self):
        start_datetime = redis_conn.get("last_nvd_query_datetime")

        if not start_datetime:
            start_datetime = (datetime.now(timezone.utc) - timedelta(days=30)).strftime(
                self.datetime_format
            )

        return start_datetime


if __name__ == "__main__":
    setup_kandji_tools()
    session = setup_database()
    inspector = inspect(session.get_bind())
    logger = logging.getLogger()
    redis_conn = setup_redis()
    request_session = requests.Session()
    retries = Retry(total=3, backoff_factor=1)
    request_session.mount("https://", HTTPAdapter(max_retries=retries))

    NVD().get_recent_data()
