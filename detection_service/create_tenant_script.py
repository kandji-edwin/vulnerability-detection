# Script to handle new tenants appearing in our service
from commands import db_writer_dsn
from postgres_models.models import DeviceOrm
from sqlalchemy import DDL
from sqlalchemy import create_engine
from sqlalchemy import inspect
from sqlalchemy.orm import sessionmaker

engine = create_engine(db_writer_dsn())
Session = sessionmaker(engine)

inherited_table_name = DeviceOrm.__tablename__


# For creating a new tenant that hasn't been seen before (uses transactional DDL)
def create_new_tenant_table(tenant_id: str):
    with Session() as session:
        insp = inspect(engine)

        trigger_tables = [
            name
            for name in insp.get_table_names()
            if name.startswith("tenant_partition")
        ]
        tenant_ids = [tenant_id] + [
            insp.get_table_comment(name)["text"] for name in trigger_tables
        ]

        first_statement = "IF {condition} THEN {action};"
        second_statement = "ELSIF {condition} THEN {action};"

        inner_function = ""

        partition_table_prefix = f"tenant_partition_{inherited_table_name}"

        hold = True
        for t_id in tenant_ids:
            condition = f"( NEW.tenant_id = '{t_id}' )"
            action = f"INSERT INTO {partition_table_prefix}_{t_id} VALUES (NEW.*)"

            if hold:
                inner_function = first_statement.format(
                    condition=condition, action=action
                )
            else:
                inner_function = f"{inner_function}{second_statement.format(condition=condition, action=action)}"
            hold = False

        # This can fail and raise an exception if ran on the same tenant more than once, but will not have negative
        # side effects
        ddl = DDL(
            f"""CREATE TABLE {partition_table_prefix}_{tenant_id} (
                CHECK ( tenant_id = '{tenant_id}')
                ) INHERITS ({inherited_table_name});
                COMMENT ON TABLE {partition_table_prefix}_{tenant_id} IS '{tenant_id}';
                
                CREATE INDEX {partition_table_prefix}_{tenant_id}_device_index ON {partition_table_prefix}_{tenant_id} ({DeviceOrm.device_id.name}); 
                CREATE INDEX {partition_table_prefix}_{tenant_id}_bundle_index ON {partition_table_prefix}_{tenant_id} ({DeviceOrm.app_bundle_identifier.name}, {DeviceOrm.app_bundle_version.name}); 
                
                CREATE OR REPLACE FUNCTION {inherited_table_name}_trigger()
                RETURNS TRIGGER AS $$
                BEGIN
                {inner_function}
                ELSE
                RAISE EXCEPTION 'No tenant table exists for tenant %%', NEW.tenant_id;
                END IF;
                RETURN NULL;
                END;
                $$
                LANGUAGE plpgsql;
                
                CREATE OR REPLACE TRIGGER insert_{inherited_table_name}
                BEFORE INSERT ON {inherited_table_name}
                FOR EACH ROW EXECUTE FUNCTION {inherited_table_name}_trigger();"""
        )
        try:
            session.execute(ddl)
            session.commit()
        except Exception as e:
            print(f"Error while trying to create tenant partition: {str(e)}")


# For deleting a tenant's partition (uses transactional DDL)
def delete_tenant_table(tenant_id: str):
    with Session() as session:
        partition_table_prefix = f"tenant_partition_{inherited_table_name}"

        ddl = DDL(
            f"""DROP TABLE {partition_table_prefix}_{tenant_id};"""
        )
        try:
            session.execute(ddl)
            session.commit()
        except Exception as e:
            print(f"Error while trying to delete tenant partition: {str(e)}")
