import logging
import os
from concurrent import futures

import grpc
from commands import setup
from commands import db_writer_dsn
from device_data import DeviceData
from dotenv import load_dotenv
from postgres_models.models import AppBundleOrm
from postgres_models.models import CPECVEMatchOrm
from postgres_models.models import CPEOrm
from postgres_models.models import CVEOrm
from postgres_models.models import DeviceOrm
from postgres_models.pydantic_types import AppBundleModel
from postgres_models.pydantic_types import CPECVEMatchModel
from postgres_models.pydantic_types import CPEModel
from postgres_models.pydantic_types import CVEModel
from postgres_models.pydantic_types import DeviceModel
from protobuf.vuln.v1 import vulnerabilities_pb2
from protobuf.vuln.v1 import vulnerabilities_pb2_grpc
from sqlalchemy import create_engine
from sqlalchemy import distinct
from sqlalchemy import select
from sqlalchemy.orm import sessionmaker
from sqlalchemy.sql.functions import count
from sqlalchemy.sql.functions import max

load_dotenv()
setup()
logger = logging.getLogger()
device_data = DeviceData()


engine = create_engine(db_writer_dsn())
Session = sessionmaker(engine)


# Service for LIT Team to use to get vulnerability info
class Vulnerabilities(vulnerabilities_pb2_grpc.Vulnerabilities):
    # Get vulnerabilities that exist on a tenant or a device on a tenant
    def GetDeviceVulnerabilities(self, request, context):
        logger.debug(f'Received GetDeviceVulnerabilities with message "{request}"')

        # Two cases - device specific and tenant specific
        if not request.device_id:
            vuln_list = []
            # Get all unique vulnerabilities existing on a tenant by looking at each device on that tenant
            with Session() as session:
                inner_stmt_bundles = (
                    select(AppBundleOrm)
                    .join_from(DeviceOrm, AppBundleOrm)
                    .where(DeviceOrm.tenant_id == request.tenant_id)
                    .distinct(
                        AppBundleOrm.bundle_version, AppBundleOrm.bundle_identifier
                    )
                )
                subq_bundles = inner_stmt_bundles.subquery()

                statement = (
                    select(CVEOrm)
                    .join_from(subq_bundles, CPEOrm)
                    .join_from(CPEOrm, CPECVEMatchOrm)
                    .join_from(CPECVEMatchOrm, CVEOrm)
                    .distinct(CVEOrm.cve_id)
                )

                result = session.execute(statement).all()
                for res in result:
                    model = CVEModel.from_orm(res[0])
                    vuln_list.append(vulnerabilities_pb2.CVEMatch(id=model.cve_id))

            return vulnerabilities_pb2.GetDeviceVulnerabilitiesResponse(cves=vuln_list)
        else:
            # Get all vulnerabilities for a device on a tenant
            vuln_list = []
            with Session() as session:
                inner_stmt_bundles = (
                    select(AppBundleOrm)
                    .join_from(DeviceOrm, AppBundleOrm)
                    .where(
                        DeviceOrm.tenant_id == request.tenant_id,
                        DeviceOrm.device_id == request.device_id,
                    )
                    .distinct(
                        AppBundleOrm.bundle_version, AppBundleOrm.bundle_identifier
                    )
                )
                subq_bundles = inner_stmt_bundles.subquery()

                statement = (
                    select(CVEOrm)
                    .join_from(subq_bundles, CPEOrm)
                    .join_from(CPEOrm, CPECVEMatchOrm)
                    .join_from(CPECVEMatchOrm, CVEOrm)
                    .distinct(CVEOrm.cve_id)
                )

                result = session.execute(statement).all()
                for res in result:
                    model = CVEModel.from_orm(res[0])
                    vuln_list.append(vulnerabilities_pb2.CVEMatch(id=model.cve_id))

            return vulnerabilities_pb2.GetDeviceVulnerabilitiesResponse(cves=vuln_list)

    # Get all devices for a specified vulnerability (for a tenant)
    def GetDevicesForVulnerability(self, request, context):
        logger.debug(f'Received GetDevicesForVulnerability with message "{request}"')

        device_list = []
        with Session() as session:
            # This should return 1 row - the CVE in the request
            inner_stmt_cve = select(CVEOrm).where(CVEOrm.cve_id == request.id)
            subq_cve = inner_stmt_cve.subquery()

            inner_stmt_devices = (
                select(DeviceOrm)
                .where(DeviceOrm.tenant_id == request.tenant_id)
                .distinct(DeviceOrm.tenant_id, DeviceOrm.device_id)
            )
            subq_devices = inner_stmt_devices.subquery()

            statement = (
                select(subq_devices)
                .join_from(subq_cve, CPECVEMatchOrm)
                .join_from(CPECVEMatchOrm, CPEOrm)
                .join_from(CPEOrm, AppBundleOrm)
                .join_from(AppBundleOrm, subq_devices)
            )

            result = session.execute(statement).all()
            for res in result:
                model = DeviceModel.from_orm(res)
                device_list.append(
                    vulnerabilities_pb2.GetDevicesForVulnerabilityResponse.Device(
                        tenant_id=model.tenant_id, device_id=model.device_id
                    )
                )

        return vulnerabilities_pb2.GetDevicesForVulnerabilityResponse(
            results=device_list
        )

    # Get info for a vulnerability (if it is found in the query)
    def GetVulnerabilityInfo(self, request, context):
        logger.debug(f'Received GetVulnerabilityInfo with message "{request}"')

        with Session() as session:
            # This should return 1 row - the CVE in the request
            statement = select(CVEOrm).where(CVEOrm.cve_id == request.id)
            result = session.execute(statement).all()

            if result:
                model = CVEModel.from_orm(result[0][0])
                cve = vulnerabilities_pb2.CVEMatch(
                    id=model.cve_id,
                    severity=model.severity,
                    score=model.score,
                    version=model.version,
                )
                return vulnerabilities_pb2.GetVulnerabilityInfoResponse(
                    found=True, cve=cve
                )
            else:
                return vulnerabilities_pb2.GetVulnerabilityInfoResponse(found=False)

    # Get overview of info for a subset of devices for a tenant
    def GetVulnerabilities(self, request, context):
        logger.debug(f'Received GetVulnerabilities with message "{request}"')

        device_info_list = []
        with Session() as session:
            # Get all overviews for every device
            if not request.device_ids:
                inner_stmt_devices = select(DeviceOrm).where(
                    DeviceOrm.tenant_id == request.tenant_id
                )
                subq_devices = inner_stmt_devices.subquery()

                statement = (
                    select(
                        subq_devices.c.tenant_id,
                        subq_devices.c.device_id,
                        count(distinct(CVEOrm.cve_id)),
                        max(CVEOrm.score),
                    )
                    .join_from(subq_devices, AppBundleOrm)
                    .join_from(AppBundleOrm, CPEOrm)
                    .join_from(AppBundleOrm, CPECVEMatchOrm)
                    .join_from(CPECVEMatchOrm, CVEOrm)
                    .group_by(subq_devices.c.tenant_id, subq_devices.c.device_id)
                )

                result = session.execute(statement).all()
                for res in result:
                    res_dict = dict(zip(res.keys(), res))
                    device_info_list.append(
                        vulnerabilities_pb2.DeviceVulnerabilitiesOverview(
                            tenant_id=res_dict["tenant_id"],
                            device_id=res_dict["device_id"],
                            number_of_vulnerabilites=res_dict["count"],
                            highest_vulnerability_score=res_dict["max"],
                        )
                    )
                return vulnerabilities_pb2.GetVulnerabilitiesResponse(
                    device_vulnerabilities=device_info_list
                )
            # Get overviews for specific devices
            else:
                inner_stmt_devices = select(DeviceOrm).where(
                    DeviceOrm.tenant_id == request.tenant_id,
                    DeviceOrm.device_id.in_(request.device_ids),
                )
                subq_devices = inner_stmt_devices.subquery()

                statement = (
                    select(
                        subq_devices.c.tenant_id,
                        subq_devices.c.device_id,
                        count(distinct(CVEOrm.cve_id)),
                        max(CVEOrm.score),
                    )
                    .join_from(subq_devices, AppBundleOrm)
                    .join_from(AppBundleOrm, CPEOrm)
                    .join_from(AppBundleOrm, CPECVEMatchOrm)
                    .join_from(CPECVEMatchOrm, CVEOrm)
                    .group_by(subq_devices.c.tenant_id, subq_devices.c.device_id)
                )

                result = session.execute(statement).all()
                for res in result:
                    res_dict = dict(zip(res.keys(), res))
                    device_info_list.append(
                        vulnerabilities_pb2.DeviceVulnerabilitiesOverview(
                            tenant_id=res_dict["tenant_id"],
                            device_id=res_dict["device_id"],
                            number_of_vulnerabilites=res_dict["count"],
                            highest_vulnerability_score=res_dict["max"],
                        )
                    )
                return vulnerabilities_pb2.GetVulnerabilitiesResponse(
                    device_vulnerabilities=device_info_list
                )

    # For a tenant, get number of vulnerable devices
    def GetNumberOfVulnerableDevices(self, request, context):
        logger.debug(f'Received GetNumberOfVulnerableDevices with message "{request}"')

        with Session() as session:
            inner_stmt_devices = select(DeviceOrm).where(
                DeviceOrm.tenant_id == request.tenant_id
            )
            subq_devices = inner_stmt_devices.subquery()

            statement = (
                select(count(distinct(subq_devices.c.device_id)))
                .join_from(subq_devices, AppBundleOrm)
                .join_from(AppBundleOrm, CPEOrm)
                .join_from(CPEOrm, CPECVEMatchOrm)
                .join_from(CPECVEMatchOrm, CVEOrm)
            )

            result = session.execute(statement).all()

            return vulnerabilities_pb2.GetNumberOfVulnerableDevicesResponse(
                number_of_vulnerable_devices=result[0][0]
            )

    # For a vulnerability, get the associated software (application bundles)
    def GetSoftwareForVulnerability(self, request, context):
        logger.debug(f'Received GetSoftwareForVulnerability with message "{request}"')

        software_list = []
        with Session() as session:
            # This should return 1 row - the CVE in the request
            inner_stmt_vuln = select(CVEOrm).where(CVEOrm.cve_id == request.id)
            subq_vuln = inner_stmt_vuln.subquery()

            statement = (
                select(AppBundleOrm)
                .join_from(subq_vuln, CPECVEMatchOrm)
                .join_from(CPECVEMatchOrm, CPEOrm)
                .join_from(CPEOrm, AppBundleOrm)
            )

            result = session.execute(statement).all()

            for res in result:
                model = AppBundleModel.from_orm(res[0])
                software_list.append(
                    vulnerabilities_pb2.GetSoftwareForVulnerabilityResponse.SoftwareInfo(
                        application_name=model.application_name,
                        version=model.version,
                        obtained_from=model.obtained_from,
                        bundle_identifier=model.bundle_identifier,
                        process=model.process_name,
                        path=model.path,
                    )
                )

        return vulnerabilities_pb2.GetSoftwareForVulnerabilityResponse(
            results=software_list
        )


def run_server():
    logger.info("Starting grpc server...")
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    identification_servicer = Vulnerabilities()
    vulnerabilities_pb2_grpc.add_VulnerabilitiesServicer_to_server(
        identification_servicer, server
    )
    server.add_insecure_port("[::]:50051")
    server.start()
    logger.info("Server started. Waiting...")
    server.wait_for_termination()


if __name__ == "__main__":
    run_server()
