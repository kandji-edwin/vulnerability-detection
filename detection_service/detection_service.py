import logging
import os
from concurrent import futures
from dotenv import load_dotenv
import grpc
from commands import setup
from device_data import DeviceData
from protobuf.vuln.v1 import vulnerabilities_pb2
from protobuf.vuln.v1 import vulnerabilities_pb2_grpc
from postgres_models.models import DeviceOrm
from postgres_models.models import CPEOrm
from postgres_models.models import CVEOrm
from postgres_models.pydantic_types import DeviceModel
from postgres_models.pydantic_types import CPEModel
from postgres_models.pydantic_types import CVEModel

load_dotenv()
setup()
logger = logging.getLogger()
device_data = DeviceData()

from sqlalchemy import create_engine, select
from sqlalchemy.orm import sessionmaker
from sqlalchemy.sql.functions import max, count

engine = create_engine(os.getenv("POSTGRES_WRITER_URI"))
Session = sessionmaker(engine)


# Service for LIT Team to use to get vulnerability info
class Vulnerabilities(vulnerabilities_pb2_grpc.Vulnerabilities):
    # Get vulnerabilities that exist on a tenant or a device on a tenant
    def GetDeviceVulnerabilities(self, request, context):
        logger.debug(f'Received GetDeviceVulnerabilities with message "{request}"')

        # Two cases - device specific and tenant specific
        if not request.device_id:
            vuln_list = []
            # Get all unique vulnerabilities existing on a tenant by looking at each device on that tenant
            with Session() as session:
                inner_stmt_devices = select(DeviceOrm).where(DeviceOrm.tenant_id == request.tenant_id)
                subq_devices = inner_stmt_devices.subquery()

                statement = select(CVEOrm).join_from(
                    subq_devices, CPEOrm).join_from(CPEOrm, CVEOrm).distinct(CVEOrm.cve_id)

                result = session.execute(statement).all()
                for res in result:
                    model = CVEModel.from_orm(res[0])
                    vuln_list.append(
                        vulnerabilities_pb2.CVEMatch(id=model.cve_id))

            return vulnerabilities_pb2.GetDeviceVulnerabilitiesResponse(cves=vuln_list)
        else:
            # Get all vulnerabilities for a device on a tenant
            vuln_list = []
            with Session() as session:
                inner_stmt_devices = select(DeviceOrm).where(DeviceOrm.tenant_id == request.tenant_id,
                                                             DeviceOrm.device_id == request.device_id)
                subq_devices = inner_stmt_devices.subquery()

                statement = select(CVEOrm).join_from(
                    subq_devices, CPEOrm).join_from(CPEOrm, CVEOrm).distinct()

                result = session.execute(statement).all()
                for res in result:
                    model = CVEModel.from_orm(res[0])
                    vuln_list.append(
                        vulnerabilities_pb2.CVEMatch(id=model.cve_id))

            return vulnerabilities_pb2.GetDeviceVulnerabilitiesResponse(cves=vuln_list)

    # Get all devices for a specified vulnerability (for a tenant)
    def GetDevicesForVulnerability(self, request, context):
        device_list = []
        with Session() as session:
            # This should return 1 row - the CVE in the request
            inner_stmt_cve = select(CVEOrm).where(CVEOrm.cve_id == request.id)
            subq_cve = inner_stmt_cve.subquery()

            inner_stmt_devices = select(DeviceOrm).where(DeviceOrm.tenant_id == request.tenant_id).distinct(
                DeviceOrm.tenant_id, DeviceOrm.device_id)
            subq_devices = inner_stmt_devices.subquery()

            statement = select(subq_devices).join_from(
                subq_cve, CPEOrm).join_from(CPEOrm, subq_devices)

            result = session.execute(statement).all()
            for res in result:
                model = DeviceModel.from_orm(res)
                device_list.append(
                    vulnerabilities_pb2.GetDevicesForVulnerabilityResponse.Device(tenant_id=model.tenant_id,
                                                                                  device_id=model.device_id))

        return vulnerabilities_pb2.GetDevicesForVulnerabilityResponse(results=device_list)

    # Get info for a vulnerability (if it is found in the query)
    def GetVulnerabilityInfo(self, request, context):
        with Session() as session:
            # This should return 1 row - the CVE in the request
            statement = select(CVEOrm).where(CVEOrm.cve_id == request.id)
            result = session.execute(statement).all()

            if result:
                model = CVEModel.from_orm(result[0][0])
                cve = vulnerabilities_pb2.CVEMatch(id=model.cve_id)
                return vulnerabilities_pb2.GetVulnerabilityInfoResponse(found=True, cve=cve)
            else:
                return vulnerabilities_pb2.GetVulnerabilityInfoResponse(found=False)

    # Get overview of info for a subset of devices for a tenant
    def GetVulnerabilities(self, request, context):
        device_info_list = []
        with Session() as session:
            # Get all overviews for every device
            if not request.device_ids:
                inner_stmt_devices = select(DeviceOrm).where(DeviceOrm.tenant_id == request.tenant_id)
                subq_devices = inner_stmt_devices.subquery()

                statement = select(subq_devices.c.tenant_id, subq_devices.c.device_id, count(),
                                   max(CVEOrm.score)).join_from(
                    subq_devices, CPEOrm).join_from(CPEOrm, CVEOrm).group_by(subq_devices.c.tenant_id,
                                                                             subq_devices.c.device_id)

                result = session.execute(statement).all()
                for res in result:
                    res_dict = dict(zip(res.keys(), res))
                    device_info_list.append(
                        vulnerabilities_pb2.DeviceVulnerabilitiesOverview(tenant_id=res_dict["tenant_id"],
                                                                          device_id=res_dict["device_id"],
                                                                          number_of_vulnerabilites=res_dict["count"],
                                                                          highest_vulnerability_score=res_dict["max"]))
                return vulnerabilities_pb2.GetVulnerabilitiesResponse(device_vulnerabilities=device_info_list)
            # Get overviews for specific devices
            else:
                inner_stmt_devices = select(DeviceOrm).where(DeviceOrm.tenant_id == request.tenant_id,
                                                             DeviceOrm.device_id.in_(request.device_ids))
                subq_devices = inner_stmt_devices.subquery()

                statement = select(subq_devices.c.tenant_id, subq_devices.c.device_id, count(),
                                   max(CVEOrm.score)).join_from(
                    subq_devices, CPEOrm).join_from(CPEOrm, CVEOrm).group_by(subq_devices.c.tenant_id,
                                                                             subq_devices.c.device_id)

                result = session.execute(statement).all()
                for res in result:
                    res_dict = dict(zip(res.keys(), res))
                    device_info_list.append(
                        vulnerabilities_pb2.DeviceVulnerabilitiesOverview(tenant_id=res_dict["tenant_id"],
                                                                          device_id=res_dict["device_id"],
                                                                          number_of_vulnerabilites=res_dict[
                                                                              "count"],
                                                                          highest_vulnerability_score=res_dict[
                                                                              "max"]))
                return vulnerabilities_pb2.GetVulnerabilitiesResponse(device_vulnerabilities=device_info_list)

    # For a tenant, get number of vulnerable devices
    def GetNumberOfVulnerableDevices(self, request, context):
        with Session() as session:
            statement = select(count()).where(DeviceOrm.tenant_id == request.tenant_id).group_by(DeviceOrm.tenant_id)
            result = session.execute(statement).all()
            print(result)
            return vulnerabilities_pb2.GetNumberOfVulnerableDevicesResponse(number_of_vulnerable_devices=result[0][0])

def run_server():
    logger.info("Starting grpc server...")
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    identification_servicer = Vulnerabilities()
    vulnerabilities_pb2_grpc.add_VulnerabilitiesServicer_to_server(
        identification_servicer, server
    )
    server.add_insecure_port("[::]:50051")
    server.start()
    logger.info("Server started. Waiting...")
    server.wait_for_termination()


if __name__ == "__main__":
    run_server()
